\documentclass{article}

\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\lstloadlanguages{C++,bash}
\lstset{basicstyle=\ttfamily,
  emphstyle=\underbar,
  language=C++
}

\newcommand{\code}[1]{\lstinline!#1!}
\newcommand{\fn}[1]{\texttt{#1}}

\title{Introductory C++ exercises}
\author{Rupert Nash \\ \url{r.nash@epcc.ed.ac.uk}}
\date{24th October 2017}

\begin{document}
\maketitle{}

The files for this are on Github at \url{https://github.com/rupertnash/cpp4computsci}. To check out the repository run:
\begin{lstlisting}[language=bash]
git clone https://github.com/rupertnash/cpp4computsci.git
cd cpp4computsci/practicals/01
\end{lstlisting}

\section{A linked list class}

\subsection{C recap}
Check that you understand the exercise we started in the lecture on
C. An example solution is on the Learn messageboard for the course.

\subsection{Reimplement this as a class}
The goal of this is to implement a very similar linked-list as a C++
class.

In \fn{PPL-C-Exercises/02-Cpp1/1-list} there is a Makefile, a test
program, a header file containing the class definition, and a partial
implementation in \fn{list.cpp}. Running \code{make} will try to build
the executable \fn{test}. This program generates some random numbers
and adds them to an instance of your list class, keeping them sorted.

When complete your program will produce output like:
\begin{lstlisting}[language=bash]
$ ./test 100
Time to insert 100 integers = 0.000142364 s
Were correctly ordered
$ ./exA 1000
Time to insert 1000 integers = 0.0025844 s
Were correctly ordered
\end{lstlisting}

You need to edit \fn{list.cpp} and complete the code. The design I
have used is very similar to the C implementation and is \emph{not}
idiomatic C++. If you can see improvements - go ahead and try them -
but note we will come back to this.

When you have this working, try to answer the following
\begin{enumerate}
\item How does it scale as you increase $N$? Try plotting on a log-log
  scale. Is this what you expected? You may wish to \code{make clean}
  and recompile with higher optimisation (add \fn{-O3} to the
  \code{CXXFLAGS} variable in the Makefile).

\item Point out a few flaws in this design. Things to consider
  include: const-correctness, RAII, having to use a non-standard
  iteration syntax.

\end{enumerate}

\section{Array}
The array is a fundamental data structure, especially for processing
large amounts of data, as it allows the system to take advantage of
the cache hierarchy. 

Recall the array template examples from the lecture - in
\fn{PPL-C-Exercises/02-Cpp1/2-array} is a basic implementation and a
(hopefully) working test program, very similar to the previous one.

Compile this and run it for a few problem sizes. What is the scaling?
How does this compare to the linked list?

We need to take a decision about copying - do we wish to allow
implicit copying which for large arrays is very slow? If not, should
we add an \emph{explicit} method to do this? What would its signature
be? How would we tell the compiler not to allow this?

\section{Libraries}
\subsection{Memory}
While we've taken a RAII approach here, it comes with some overhead:
we had to implement (or delete) five functions: the destructor, the
copy constructor, the move constructor, the copy assignment operator,
and the move assignment operator. This concept is known as ``the rule
of five'' (before C++11 it only had three).

A more idiomatic approach is to wrap the resource into a class that
does nothing but manage a resource, then it can be used elsewhere and
the compiler will produce correct implicit constructors, destructor
and assignment operators with no boilerplate code!

See \cite{rule3} or \cite{meyers-rule0} for an in-depth discussion.

Fortunately the standard library includes several ``smart pointers''
that will do this for you for memory! They can be accessed using the
\code{<memory>} header.

They are:
\begin{itemize}
\item \code{std::unique_ptr} - this uniquely owns the pointed-to
  object. The object is deleted (can be customised) when the smart
  pointer destructs or you assign a new value. You cannot copy a
  \code{unique_ptr}. \emph{This should be your default pointer type!}

\item \code{std::shared_ptr} - this shares ownership of the pointed-to
  object. All the child \code{shared_ptr}s  point to the same object. The
  object will be deleted when \emph{all} the pointers are either
  destructed or assigned a new value.

\item \code{std::weak_ptr} - much like a \code{shared_ptr} but it
  doesn't own a share of the object. It can become invalid. Used to
  break reference cycles.
\end{itemize}

(There also exists a \code{std::auto_ptr}. This is deprecated and has
been removed from C++17, so do not use it.)

Have a look at the reference
\url{http://en.cppreference.com/w/cpp/memory} and re-implement
\code{Array} using either a unique or shared pointer.


\subsection{Containers}
The standard library also has a number of containers for
objects. These include a list template class (typically a
doubly-linked list) and a vector which is a contiguous dynamically
sized array a bit like our \code{Array<T>}. There are also hash
tables, queues (single and double ended), stacks, etc.

The full list is here \url{http://en.cppreference.com/w/cpp/container}.

Replace your list with \code{std::list<int>} and compare performance.

Try the same with replacing your array with \code{std::vector}.

\begin{thebibliography}{9}
\bibitem{rule3}
  \url{http://en.cppreference.com/w/cpp/language/rule_of_three}
\bibitem{meyers-rule0}
  \url{http://scottmeyers.blogspot.co.uk/2014/03/a-concern-about-rule-of-zero.html}
\end{thebibliography}
\end{document}
