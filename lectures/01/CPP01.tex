\documentclass[presentation,t]{beamer}
\usetheme{EPCC}

% underline \emph{}
\usepackage{ulem}
\usepackage{listings}
\lstloadlanguages{C++,bash}
\lstset{basicstyle=\ttfamily,
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  commentstyle=\color{magenta}\ttfamily,
  morecomment=[l][\color{magenta}]{\#},
  emphstyle=\underbar,
  language=C
}

\newcommand{\code}[1]{\lstinline!#1!}

% \usepackage{tikz}
% \usetikzlibrary{backgrounds,fit,calc,shapes,arrows,through,decorations.pathmorphing}

\author{Rupert Nash\\ \url{r.nash@epcc.ed.ac.uk}}
\date{23rd October 2017}
\title{A brief introduction to C++}


\begin{document}

\frame{\titlepage}
\section{Introduction}

\begin{frame}{References}
  \begin{itemize}
  \item Bjarne Stroustrup, ``Programming: Principles and Practice
    Using C++'' (2nd Ed.). Assumes very little but it's long
  \item Bjarne Stroustrup, ``A Tour of C++''. Assumes you're an
    experience programmer and is quite brief.
  \item Best online \emph{reference} I've found is
    \url{http://en.cppreference.com/} (Comes other human languages
    too!)
  \item Scott Meyers, ``Effective Modern C++'', 2014. This is
    \emph{the} book to get once you know your way around C++, but you
    want to improve. Teaches lots of techniques and rules of thumb for
    writing correct, idiomatic, maintainable code.
  \item \url{stackoverflow.com} has a lot of good questions about C++
    (look for ones with at least 100 up-votes).
  \end{itemize}
\end{frame}

  \begin{frame}{Misunderstood monsters: Frankenstein's vs. C++}
  \only<1>{
    \begin{center}
      \includegraphics[height=0.4\textwidth]{frank_mon}
      \footnote{By Universal Studios - Dr. Macro, Public Domain,
        https://commons.wikimedia.org/w/index.php?curid=3558176}

    \end{center}
  }
  \only<2->{
    \begin{itemize}
    \item Large: the C++11 standard is about 1300 pages
    \item Composed of many parts: C, classes, generics, functional
      programming, exceptions, the vast library, \ldots
    \item Inspires dread in those do not understand it
    \item Dangerous: ``C makes it easy to shoot yourself in the foot;
      C++ makes it harder, but when you do it blows your whole leg
      off.'' -- Bjarne Stroustrup
    \item ``Expert friendly''
    \end{itemize}
  }
\end{frame}

\begin{frame}{Octopus vs Swiss Army knife}
  ``C++ is an octopus made by nailing extra legs onto a dog'' -- Steve
  Taylor
  \begin{figure}
    \includegraphics[width=0.4\textwidth]{octodog}
    \hfill
    \includegraphics[width=0.4\textwidth]{sak}
  \end{figure}
  But you can cut off some extra legs to get the right dog for your
  program!
\end{frame}

\begin{frame}{The philosophy of C++}
  \begin{itemize}
  \item General purpose

  \item Flexible by allowing developers to build abstractions (and
    provides a large number through the library)

  \item Performance and efficiency always targeted
    ``You only pay for what you use''

  \item Use the powerful type system to express intent.
  \end{itemize}
\end{frame}

\begin{frame}{These few lectures}
  We could spend all semester going in depth on C++, but we've got
  three lectures plus a ``drop in''.

  So I've picked a handful of features to cover today that you really
  need to write C++ for HPC:
  \begin{itemize}
  \item References and memory
  \item Overloading
  \item Classes
  \item Templates
  \end{itemize}
\end{frame}

\newcommand{\helloworld}[1]{
  \lstinputlisting[language=C,emph={#1}]{hello/hello.cpp}\hfill
}
\section{But first...}

\begin{frame}[fragile]{Hello!}
  \helloworld{}
  \pause
\begin{lstlisting}[language=bash]
$ g++ --std=c++11 hello.cpp -o hello
$ ./hello 
Hello, world!
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Hello!}
  \helloworld{iostream}

  Include the \code{iostream} standard library header which gives us a
  way to communicate with the file system
\end{frame}

\begin{frame}[fragile]{Hello!}
  \helloworld{std}
  
  \code{std} is the standard library namespace. A namespace allows
  scoping of names (much like a filesystem has directories).
  \vfill
  The scope resolution operator \code{::} lets us access a declaration
  from inside a namespace.
\end{frame}

\begin{frame}[fragile]{Hello!}
  \helloworld{cout}

  \code{cout} represents console output (i.e. stdout)
\end{frame}

\begin{frame}[fragile]{Hello!}
  \helloworld{<<}
  
  The standard library uses the bitwise left shift operator
  (\code{<<}) to mean stream insertion - i.e. output the right hand
  side to the left.
  \vfill{}
  (Similarly, the right shift (\code{>>}) operator is used for
  extraction, i.e. input.)
\end{frame}

\section{Memory and references}

\begin{frame}[fragile]{Don't use malloc again}
  While you can use \code{malloc} and \code{free} in C++, you should
  not.

  Instead, if you need to directly allocate memory use \code{new} and
  \code{delete}.
  
\begin{lstlisting}
int* x = nullptr;
x = new int;
*x = 42;
std::cout << "The answer is "<< *x <<std::endl;
// The answer is 42
delete x;
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Slightly different for arrays}
\begin{lstlisting}
int* squares = nullptr;
squares = new int[5];
for (auto i=0; i<5; ++i)
  squares[i] = i*i;

// Do something
delete[] squares;
\end{lstlisting}

Note the square brackets!
\end{frame}

\begin{frame}[fragile]{References}
  As well as pointers and values, C++ has the concept of a
  \emph{reference}. They are like pointers in that they don't copy the
  thing-that-is-referred-to, but syntactically they are just like a value.

\begin{lstlisting}
double pi = 3.14;
double& pr = pi;
std::cout << pr << std::endl;

void iLoveIntegers(double& x) {
  x = 3;
}
iLoveIntegers(pi);
\\ prints 3
std::cout << pi << std::endl;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{References: whys and whens}
References have simpler syntax.

References are safer than pointers: a reference cannot be null and
cannot be reseated (must be bound when it's defined)
\begin{lstlisting}
double twopi = 6.24;
pr = twopi; \\ Error will not compile
\end{lstlisting}

And you can rely on it being valid, unless there is an
evil coder around:
\begin{lstlisting}
char& get() {
  char x = '!';
  return x;
  // Many compilers will warn about this
}
\end{lstlisting}

Use a reference by default, until you need a pointer. (E.g. need to
reseat or interface with C.)
\end{frame}

\section{Overloading}
\begin{frame}[fragile]{Function overloading}
  You can have multiple functions with the \emph{same name} but
  \emph{different arguments}.
  
\begin{lstlisting}
int sum(int a, int b) {
  return a + b;
}
double sum(double a, double b) {
  return a + b;
}
\end{lstlisting}

  When you call \code{sum}, the compiler knows the types of the
  arguments and will try to find the best match from all the
  candidates with the name.
  \vfill{}
  The compiler will also try to use any built-in or user-defined
  conversion rules.
\end{frame}

\begin{frame}[fragile]{What happens here?}
\begin{lstlisting}
  int i1 = 1;
  int i2 = 2;
  double d1 = 1.0;
  double d2 = 2.0;
  unsigned u42 = 42;
  
  std::cout << sum(i1, i2) << std::endl;
  std::cout << sum(3, 72) << std::endl;
  std::cout << sum(i1, u42) << std::endl;
  std::cout << sum(d2, d1) << std::endl;
  std::cout << sum(d2, i1) << std::endl;
  std::cout << sum(d2, 1.0f) << std::endl;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Operators are functions}
  C++ operators, for the non-built in types, are just functions with
  odd names, e.g.:
\begin{lstlisting}
Vector operator+(const Vector& a,
                 const Vector& b);
\end{lstlisting}
  You can then use the natural syntax when manipulating these in other
  code:
\begin{lstlisting}
Vector c = a + b;
\end{lstlisting}
  We'll come back to this.
\end{frame}

\section{Classes}
\begin{frame}[fragile]{Objects in C++}
  You define a class just like a \code{struct}, but using the keyword
  \code{class} instead.\footnote{Technically, the only difference is
    the default visibility of declarations.}
  
  As well as \emph{data members}, instantiations of classes
  (i.e. objects) can have \emph{member functions}.

\begin{lstlisting}
class Complex {
public:
  Complex();
  Complex(float re, float im);
  Complex(const Complex&) = default;
  float magnitude() const;
private:
  float real;
  float imag;
};
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Creating complexes}
  When you create an instance of your class, you usually need to
  provide a \emph{constructor}. Note we provide two overloads - a
  default one needing no arguments and one that initialises with a
  value.

  We also tell the compiler to create a \emph{default copy
    constructor} for us.

\begin{lstlisting}
Complex::Complex() :
  real(0), imag(0) {
}
Complex::Complex(float re, float im) :
  real(re), imag(im) {
}
// This is roughly what the compiler will create
// Complex::Complex(const Complex& c) :
//   real(c.real), imag(c.imag) {
// }

\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Creating complexes}
We can now create these numbers
\begin{lstlisting}
  Complex zero;
  Complex imaginary_unit(0, 1);
  Complex copy_of_i(imaginary_unit);
\end{lstlisting}
What about actually doing something?
\end{frame}

\begin{frame}[fragile]{}
\begin{lstlisting}
float Complex::magnitude() const {
  return real*real + imag*imag;
}
\end{lstlisting}
  \begin{itemize}
  \item The \code{const} at the end of the declaration says that this
    function will not alter the instance it is working on. Add this
    whenever possible!

  \item We can access the members by just giving their names.

  \item The instance that the function is working on is also available
    as a pointer, called \code{this}, so could rewrite as:
  \end{itemize}
\begin{lstlisting}
float Complex::magnitude() const {
  return this->real*this->real +
           this->imag*this->imag;
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{}
  Complex numbers have the usual arithmetic operations: ($+-\times\div$)% add, subtract,
%  multiply, divide.
  
  We have to provide operator overloads, like
\begin{lstlisting}
Complex operator+(const Complex& a,
                    const Complex& b) {
  return Complex{a.real+b.real, a.imag+b.imag};
}
\end{lstlisting}
  This is just a function (with an unusual name) that takes two
  complex numbers and returns one.

  To let this function touch the private members of the class, we must
  declare that it is a \code{friend}:
\begin{lstlisting}
class Complex {
  // ...
  friend Complex operator+(const Complex&, const Complex&);
};
\end{lstlisting}
\end{frame}

\section{Templates}
\begin{frame}[fragile]{Templates 101}
  Templates are a method of doing \emph{metaprogramming}: a program
  that writes a program.
\vfill
  An easy example:
  \begin{onlyenv}<1>
\begin{lstlisting}
int sum(int a, int b) {
  return a+b;
}
double sum(double a, double b) {
  return a+b;
}
\end{lstlisting}
    
    What if we need this for \code{float} and \code{unsigned}?
    
    Going to get boring and hard to maintain quickly!
  \end{onlyenv}

  \begin{onlyenv}<2>
\begin{lstlisting}
template<class T>
T sum(T a, T b) {
  return a+b;
}
\end{lstlisting}

    When you use it later, the compiler will substitute the types you
    supply for \code{T} and then try to compile the template.

\begin{lstlisting}
cout <<"add unsigned=" << sum(1U, 4U) << endl;
cout <<"add floats=" << sum(1.0f, 4e-2f) << endl;
\end{lstlisting}
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile]{Template classes}
  You can define a template class - i.e. a template that will produce
  a class when you instatiate it.

  Let's build something useful, like a simple array class.

\begin{lstlisting}
template<class T>
class Array {
  unsigned _size;
  T* _data;
public:
  Array();
  Array(unsigned n);
  ~Array();
  unsigned size() const;
  const T& operator[](unsigned i) const;
  T& operator[](unsigned i);
};
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Where to put your implementation?}
  Templates are \emph{not} executable code - they tell the compiler
  how to create it. So the definition must be available to the user of
  your template - i.e. typically in a header file.
  
  You can define the functions in place like:
\begin{lstlisting}
template<class T>
class Array {
public:
  Array() : _size(0), _data(nullptr) {}
};
\end{lstlisting}
  Or at the end of the header (or equivalently in another file that
  you include at the end of your header)
\begin{lstlisting}
template<class T>
Array<T>::Array(unsigned n) : _size(n) {
  _data = new T[n];
}
\end{lstlisting}
  
\end{frame}

\begin{frame}[fragile]{How to release that memory?}
  We have acquired some memory in the constructor and at the moment we
  will leak this.
  
  Typically a class's \emph{destructor} will do this.
  
  % note lstinline can't hack ~ when it's in a funny env like frame...
  The name of this function is \texttt{\~\!Array}
\begin{lstlisting}
template<class T>
Array<T>::~Array() {
  delete[] _data;
}
\end{lstlisting}
  
  It's important to note that you should never call this directly -
  the compiler will call it for you when your \code{Array} objects:
  \begin{itemize}
  \item go out of scope (i.e. local variables)
  \item are \code{delete}d
  \item belong to another object and that object is destructed
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{RAII / CADRe}
  A very important pattern in C++ is \emph{RAII}: resource allocation
  is instantiation. Also known as constructor acquires, destructor
  releases.

  This odd name is trying to communicate that any resource you have
  (heap memory in this case) should be tied to the lifetime of an
  object. So the when the compiler destroys your object it will release
  the resource (e.g. memory).

\begin{lstlisting}
void do_simulation(Parameters& p) {
  Array<float> work_array(p.problem_size);
  initial_condition(work_array);
  for(int i=0; i<p.timesteps; ++i) {
    do_timestep(work_array);
  }
  write_output(p.outfile, work_array);
}
\end{lstlisting}
\end{frame}

\begin{frame}{Copying}
  One thing we've not discussed about this array is what do we want to
  do about copying?
  \begin{itemize}
  \item We could create a shallow copy, using a simple pointer copy,
    but then which instance owns the data?

  \item We could instead do a deep copy of the data each time, but
    that might be expensive. Maybe we want to disallow implicit
    copying but allow a user to explicitly copy with a special
    \code{copy()} method?
  \end{itemize}
  These design decisions should be considered!
\end{frame}

\begin{frame}[fragile]{Returning an Array}
  What happens if we compute an array in a function and return it?
  
\begin{lstlisting}
Array<int> load(const string& fn) {
  auto n = getsize(fn);
  Array<int> ans(n);
  for (auto i=0; i<n; ++i)
    ans[i] = read(fn, i);
  return ans;
}

void user() {
  Array<int> data = load(fn);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Returning an Array}
  People assume this is what happens:
\begin{lstlisting}
Array<int> load(const string& fn) {
  auto n = getsize(fn);
  Array<int> ans(n); // allocate
  for (auto i=0; i<n; ++i)
    ans[i] = read(fn, i);
  return ans; // copy to a temporary
}

void user() {
  // Call default c'tor
  Array<int> data = load(fn); // copy tmp->data
                              // destroy tmp
}
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]{Returning an Array}
  Alternative: return a pointer
\begin{lstlisting}
Array<int>* load(const string& fn) {
  auto n = getsize(fn);
  // OMG - new!
  auto ans = new Array<int>(n); //allocate twice
  for (auto i=0; i<n; ++i)
    // UGLY!
    (*ans)[i] = read(fn, i);
  return ans;
}

void user() {
  auto data = load(fn);
 // Better remember to delete this!
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Returning an Array}
  Alternative: pass an output argument by reference
\begin{lstlisting}
void load(const string& fn, Array<int>& ans) {
  auto n = getsize(fn);
  ans.resize(n); // probably allocate
  for (auto i=0; i<n; ++i)
    ans[i] = read(fn, i);
}

void user() {
  // Have to declare outside factory function :(
  Array<int> data;
  load(fn, data); // No copy :)
  // Regressing to assembly :(
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Returning an Array}
  Alternative: don't copy - move

  Need to define a new \emph{move} constructor and assignment

\begin{lstlisting}
template<class T>
class Array {
public:
  Array(Array&& other) :
    _size(other._size), _data(other._data) {
    other._data = nullptr;
    other._size = 0;
  }
};
\end{lstlisting}

  The double ampersand indicates an ``r-value reference''. \\
  The compiler will only use this when the argument is a temporary
  value that is going to be destructed - you can safely steal its
  resources.
\end{frame}


\begin{frame}[fragile]{Returning an Array}
  Alternative: don't copy - move
\begin{lstlisting}
Array<int> load(const string& fn) {
  auto n = getsize(fn);
  Array<int> ans(n); // Construct
  for (auto i=0; i<n; ++i)
    ans[i] = read(fn, i);
  return ans; // This moves to the temporary
}

void user() {
  Array<int> data = load(fn); // temporary moved to data
                              // temporary destructed
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Returning an Array}
  Compilers are allowed to do \emph{copy elision} (even when this may
  have side effects!) to directly construct the return value in its
  destination
\begin{lstlisting}
// Compiler adds secret arg 
Array<int> load(const string& fn) {
  auto n = getsize(fn);
  Array<int> ans(n); // Alias ans to secret
                     // Construct
  for (auto i=0; i<n; ++i)
    ans[i] = read(fn, i);
  return ans; // No-op
}

void user() {
  // Create empty space for data
  Array<int> data = load(fn); // pass data as secret arg          
}
\end{lstlisting}
In C++17 this is \emph{required}
\end{frame}


% \begin{frame}{Practical}
%   The practical will have you rewriting the list example with
%   C++ and improving this Array template. You will then try using the
%   STL: the standard template library instead.

%   See Learn for the details.
% \end{frame}

\end{document}
